vertical_line_date <- as.Date("2024-11-06")
ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile() +
scale_fill_manual(
values = c("darkgrey", "lightblue", "blue", "darkblue", "black", "red"),  # Custom colors
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "black", linetype = "dashed", size = 1) +
labs(
title = "",
x = "Date",
y = "User",
fill = "Post count"
) +
theme_minimal(base_size = 14) +
theme(
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank()
)
# Create Tile Plot with Custom Binning and Vertical Line
tile_plot <- ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile() +
scale_fill_manual(
values = c("darkgrey", "lightblue", "blue", "darkblue", "black", "red"),  # Custom colors
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "black", linetype = "dashed", size = .5) +
labs(
title = "",
x = "Date",
y = "User",
fill = "Post count"
) +
theme_minimal(base_size = 14) +
theme(
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank()
)
# Create a 'plots' directory
plots_dir <- file.path(processed_dir, "plots")
if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
# Save the Tile Plot in the 'plots' directory
tile_plot_path <- file.path(plots_dir, "tile_plot.png")
ggsave(tile_plot_path, tile_plot, width = 12, height = 4, dpi = 300)
ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile() +
scale_fill_manual(
values = c("darkgrey", "lightblue", "blue", "darkblue", "black", "red"),  # Custom colors
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "black", linetype = "dashed", size = .5) +
labs(
title = "",
x = "Date",
y = "User",
fill = "Post count"
) +
theme_minimal(base_size = 14) +
theme(
panel.background = element_rect(fill = "white", color = NA),  # Set panel background to white
plot.background = element_rect(fill = "white", color = NA),   # Set plot background to white
legend.background = element_rect(fill = "white", color = NA), # Set legend background to white
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank()  # Remove gridlines for a cleaner heatmap
)
tile_plot <- ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile() +
scale_fill_manual(
values = c("darkgrey", "lightblue", "blue", "darkblue", "black", "red"),  # Custom colors
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "black", linetype = "dashed", size = .5) +
labs(
title = "",
x = "Date",
y = "User",
fill = "Post count"
) +
theme_minimal(base_size = 14) +
theme(
panel.background = element_rect(fill = "white", color = NA),  # Set panel background to white
plot.background = element_rect(fill = "white", color = NA),   # Set plot background to white
legend.background = element_rect(fill = "white", color = NA), # Set legend background to white
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank()  # Remove gridlines for a cleaner heatmap
)
# Create a 'plots' directory
plots_dir <- file.path(processed_dir, "plots")
if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
# Save the Tile Plot in the 'plots' directory
tile_plot_path <- file.path(plots_dir, "tile_plot.png")
ggsave(tile_plot_path, tile_plot, width = 12, height = 4, dpi = 300)
View(posting_behavior)
# Load required libraries
library(gt)
# Select top 10 posters
top_posters <- posting_behavior %>%
arrange(desc(total_posts)) %>%
slice_head(n = 10)
# Create a styled table using gt
top_posters_table <- top_posters %>%
gt() %>%
tab_header(
title = "Top 10 Posters (Accounts Created in 2023)",
subtitle = "Ranked by Total Number of Posts"
) %>%
fmt_number(
columns = vars(total_posts, active_days),
decimals = 0
) %>%
cols_label(
author_handle = "User Handle",
total_posts = "Total Posts",
first_post_date = "First Post",
last_post_date = "Last Post",
active_days = "Active Days"
) %>%
data_color(
columns = vars(total_posts),
colors = scales::col_numeric(
palette = c("lightblue", "blue", "darkblue"),
domain = NULL
)
) %>%
tab_options(
table.font.size = "medium",
table.border.top.style = "none",
table.border.bottom.style = "none"
)
# Save the table as an image for social media
output_table_path <- file.path("bsky_data/processed/", "top_posters_table.png")
gtsave(top_posters_table, output_table_path)
# Load required libraries
library(gt)
# Select top 10 posters
top_posters <- posting_behavior %>%
arrange(desc(total_posts)) %>%
slice_head(n = 10)
# Create a styled table using gt
top_posters_table <- top_posters %>%
gt() %>%
tab_header(
title = "Top 10 Posters (Accounts Created in 2023)",
subtitle = "Ranked by Total Number of Posts"
) %>%
fmt_number(
columns = vars(total_posts, active_days),
decimals = 0
) %>%
cols_label(
author_handle = "User Handle",
total_posts = "Total Posts",
first_post_date = "First Post",
last_post_date = "Last Post",
active_days = "Active Days"
) %>%
data_color(
columns = vars(total_posts),
colors = scales::col_numeric(
palette = c("lightblue", "blue", "darkblue"),
domain = NULL
)
) %>%
tab_options(
table.font.size = "medium",
table.border.top.style = "none",
table.border.bottom.style = "none"
)
# Save the table as an image for social media
output_table_path <- file.path("bsky_data/processed/", "top_posters_table.png")
gtsave(top_posters_table, output_table_path)
# Enhanced Tile Plot with Borders and Dark Background
tile_plot <- ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile(color = "grey") +  # Add grey borders to tiles
scale_fill_manual(
values = c("white", "lightblue", "blue", "darkblue", "red", "yellow"),  # Vibrant colors for contrast
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "white", linetype = "dashed", size = 0.8) +  # Make vertical line white for visibility
labs(
title = "User Posting Frequency Over Time (2024)",
x = "Date",
y = "User",
fill = "Post Count"
) +
theme_minimal(base_size = 14) +
theme(
panel.background = element_rect(fill = "black", color = NA),  # Set panel background to black
plot.background = element_rect(fill = "black", color = NA),   # Set plot background to black
legend.background = element_rect(fill = "black", color = NA), # Set legend background to black
legend.text = element_text(color = "white"),  # Make legend text white
legend.title = element_text(color = "white"), # Make legend title white
axis.text.x = element_text(color = "white"),  # Make axis text white
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
axis.title.x = element_text(color = "white"), # Make axis titles white
axis.title.y = element_text(color = "white"), # Make axis titles white
plot.title = element_text(hjust = 0.5, face = "bold", color = "white"),  # Make plot title white
panel.grid = element_blank()  # Remove gridlines for a cleaner heatmap
)
tile_plot
ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile() +  # Add grey borders to tiles
scale_fill_manual(
values = c("white", "lightblue", "blue", "darkblue", "red", "yellow"),  # Vibrant colors for contrast
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "white", linetype = "dashed", size = 0.8) +  # Make vertical line white for visibility
labs(
title = "User Posting Frequency Over Time (2024)",
x = "Date",
y = "User",
fill = "Post Count"
) +
theme_minimal(base_size = 14) +
theme(
panel.background = element_rect(fill = "black", color = NA),  # Set panel background to black
plot.background = element_rect(fill = "black", color = NA),   # Set plot background to black
legend.background = element_rect(fill = "black", color = NA), # Set legend background to black
legend.text = element_text(color = "white"),  # Make legend text white
legend.title = element_text(color = "white"), # Make legend title white
axis.text.x = element_text(color = "white"),  # Make axis text white
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
axis.title.x = element_text(color = "white"), # Make axis titles white
axis.title.y = element_text(color = "white"), # Make axis titles white
plot.title = element_text(hjust = 0.5, face = "bold", color = "white"),  # Make plot title white
panel.grid = element_blank()  # Remove gridlines for a cleaner heatmap
)
# Enhanced Tile Plot with Borders and Dark Background
tile_plot <- ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile() +  # Add grey borders to tiles
scale_fill_manual(
values = c("white", "lightblue", "blue", "darkblue", "red", "yellow"),  # Vibrant colors for contrast
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "white", linetype = "dashed", size = 0.8) +  # Make vertical line white for visibility
labs(
title = "User Posting Frequency Over Time (2024)",
x = "Date",
y = "User",
fill = "Post Count"
) +
theme_minimal(base_size = 14) +
theme(
panel.background = element_rect(fill = "black", color = NA),  # Set panel background to black
plot.background = element_rect(fill = "black", color = NA),   # Set plot background to black
legend.background = element_rect(fill = "black", color = NA), # Set legend background to black
legend.text = element_text(color = "white"),  # Make legend text white
legend.title = element_text(color = "white"), # Make legend title white
axis.text.x = element_text(color = "white"),  # Make axis text white
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
axis.title.x = element_text(color = "white"), # Make axis titles white
axis.title.y = element_text(color = "white"), # Make axis titles white
plot.title = element_text(hjust = 0.5, face = "bold", color = "white"),  # Make plot title white
panel.grid = element_blank()  # Remove gridlines for a cleaner heatmap
)
# Create a 'plots' directory
plots_dir <- file.path(processed_dir, "plots")
if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
# Save the Tile Plot in the 'plots' directory
tile_plot_path <- file.path(plots_dir, "tile_plot.png")
ggsave(tile_plot_path, tile_plot, width = 12, height = 4, dpi = 300)
# Enhanced Tile Plot with Borders and Dark Background
tile_plot <- ggplot(tile_data, aes(x = date, y = author_handle, fill = post_count_bin)) +
geom_tile() +  # Add grey borders to tiles
scale_fill_manual(
values = c("white", "lightblue", "blue", "darkblue", "red", "yellow"),  # Vibrant colors for contrast
name = "Posts"
) +
geom_vline(xintercept = vertical_line_date, color = "white", linetype = "dashed", size = 0.8) +  # Make vertical line white for visibility
labs(
title = "",
x = "Date",
y = "User",
fill = "Posts"
) +
theme_minimal(base_size = 14) +
theme(
panel.background = element_rect(fill = "black", color = NA),  # Set panel background to black
plot.background = element_rect(fill = "black", color = NA),   # Set plot background to black
legend.background = element_rect(fill = "black", color = NA), # Set legend background to black
legend.text = element_text(color = "white"),  # Make legend text white
legend.title = element_text(color = "white"), # Make legend title white
axis.text.x = element_text(color = "white"),  # Make axis text white
axis.text.y = element_blank(),  # Hide user names for better readability
axis.ticks.y = element_blank(),
axis.title.x = element_text(color = "white"), # Make axis titles white
axis.title.y = element_text(color = "white"), # Make axis titles white
plot.title = element_text(hjust = 0.5, face = "bold", color = "white"),  # Make plot title white
panel.grid = element_blank()  # Remove gridlines for a cleaner heatmap
)
# Create a 'plots' directory
plots_dir <- file.path(processed_dir, "plots")
if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
# Save the Tile Plot in the 'plots' directory
tile_plot_path <- file.path(plots_dir, "tile_plot.png")
ggsave(tile_plot_path, tile_plot, width = 12, height = 4, dpi = 300)
# Load libraries
library(dplyr)
library(ggplot2)
library(cowplot)
library(lubridate)
# Create the processed directory
processed_dir <- "bsky_data/processed/"
combined_posts <- readRDS(file.path(processed_dir, "combined_posts.rds"))
test <- readRDS("/Users/christopherbarrie/Dropbox/sandbox/atrrr/bsky_data/bbcnewsnight/posts/1-flightless-bird.bsky.social.rds")
View(test)
test <- readRDS("/Users/christopherbarrie/Dropbox/sandbox/atrrr/bsky_data/bbcnewsnight/posts/3-things.bsky.social.rds")
View(test)
test <- readRDS("/Users/christopherbarrie/Dropbox/sandbox/atrrr/bsky_data/bbcnewsnight/posts/zzglenm.bsky.social.rds")
View(test)
View(combined_posts)
combined_posts %>%
filter(!is.na(text))
empties <- combined_posts %>%
filter(!is.na(text))
View(combined_posts)
empties <- combined_posts %>%
filter(is.na(text))
# Load libraries
library(dplyr)
library(ggplot2)
library(cowplot)
library(lubridate)
# Define the newspapers and their directories
outlets <- list(
bbcnewsnight = "bsky_data/bbcnewsnight/posts/",
telegraph = "bsky_data/tgraph/posts/",
guardian = "bsky_data/guardian/posts/"
)
# Initialize an empty list to store data
all_posts <- list()
# Create the processed directory
processed_dir <- "bsky_data/processed/"
if (!dir.exists(processed_dir)) dir.create(processed_dir, recursive = TRUE)
# Load posts from each outlet
for (source in names(outlets)) {
post_files <- list.files(outlets[[source]], full.names = TRUE, pattern = "\\.rds$")
# Create a data frame for users with no posts
users <- basename(post_files) %>% gsub("\\.rds$", "", .)
source_posts <- lapply(post_files, function(file) {
data <- readRDS(file)
if (is.data.frame(data)) {
data <- data %>% mutate(source = source)  # Add source label
} else {
# Handle users with no posts
data <- data.frame(author_handle = gsub("\\.rds$", "", basename(file)), source = source)
}
return(data)
})
# Bind rows for each source
all_posts[[source]] <- bind_rows(source_posts)
}
# Combine all posts into one dataset
combined_posts <- bind_rows(all_posts)
# Ensure empty rows for users with no posts
all_users <- unique(combined_posts$author_handle)
combined_posts <- combined_posts %>%
group_by(author_handle) %>%
complete(author_handle = all_users, fill = list(source = NA)) %>%
ungroup()
library(tidyr)
# Load libraries
library(dplyr)
library(ggplot2)
library(cowplot)
library(lubridate)
library(tidyr)
# Define the newspapers and their directories
outlets <- list(
bbcnewsnight = "bsky_data/bbcnewsnight/posts/",
telegraph = "bsky_data/tgraph/posts/",
guardian = "bsky_data/guardian/posts/"
)
# Initialize an empty list to store data
all_posts <- list()
# Create the processed directory
processed_dir <- "bsky_data/processed/"
if (!dir.exists(processed_dir)) dir.create(processed_dir, recursive = TRUE)
# Load posts from each outlet
for (source in names(outlets)) {
post_files <- list.files(outlets[[source]], full.names = TRUE, pattern = "\\.rds$")
# Create a data frame for users with no posts
users <- basename(post_files) %>% gsub("\\.rds$", "", .)
source_posts <- lapply(post_files, function(file) {
data <- readRDS(file)
if (is.data.frame(data)) {
data <- data %>% mutate(source = source)  # Add source label
} else {
# Handle users with no posts
data <- data.frame(author_handle = gsub("\\.rds$", "", basename(file)), source = source)
}
return(data)
})
# Bind rows for each source
all_posts[[source]] <- bind_rows(source_posts)
}
# Combine all posts into one dataset
combined_posts <- bind_rows(all_posts)
# Ensure empty rows for users with no posts
all_users <- unique(combined_posts$author_handle)
combined_posts <- combined_posts %>%
group_by(author_handle) %>%
complete(author_handle = all_users, fill = list(source = NA)) %>%
ungroup()
# Ensure empty rows for users with no posts
all_users <- unique(combined_posts$author_handle)
combined_posts <- combined_posts %>%
group_by(author_handle) %>%
complete(author_handle = all_users, fill = list(source = NA)) %>%
ungroup()
# Remove duplicates
unique_posts <- combined_posts %>%
distinct(across(everything()))  # Adjust columns for uniqueness if needed
# Ensure empty rows for users with no posts
all_users <- unique(combined_posts$author_handle)
all_users
combined_posts <- combined_posts %>%
group_by(author_handle) %>%
complete(author_handle = all_users, fill = list(source = NA)) %>%
ungroup()
View(combined_posts)
empties <- combined_posts %>%
filter(is.na(text))
empties <- combined_posts %>%
filter(is.na(text))
# Combine all posts into one dataset
combined_posts <- bind_rows(all_posts)
empties <- combined_posts %>%
filter(is.na(text))
View(empties)
# Ensure all unique users are represented
all_users <- unique(combined_posts$author_handle)
# Create a data frame with all unique users and sources
empty_users <- data.frame(
author_handle = all_users,
source = NA,  # Placeholder for missing sources
stringsAsFactors = FALSE
)
# Bind rows for missing users and ensure all users are included
combined_posts <- bind_rows(combined_posts, empty_users) %>%
distinct(author_handle, .keep_all = TRUE)
View(combined_posts)
empties <- combined_posts %>%
filter(is.na(text))
View(combined_posts)
empties <- combined_posts %>%
filter(text=="")
# Bind rows for missing users and ensure all users are included
combined_posts <- bind_rows(empties) %>%
distinct(author_handle, .keep_all = TRUE)
# Combine all posts into one dataset
combined_posts <- bind_rows(all_posts)
# Combine all posts into one dataset
combined_posts <- bind_rows(all_posts)
empties <- combined_posts %>%
filter(text=="")
combined_posts %>%
filter(text=="")
# Load libraries
library(dplyr)
library(ggplot2)
library(cowplot)
library(lubridate)
library(tidyr)
# Define the newspapers and their directories
outlets <- list(
bbcnewsnight = "bsky_data/bbcnewsnight/posts/",
telegraph = "bsky_data/tgraph/posts/",
guardian = "bsky_data/guardian/posts/"
)
# Initialize an empty list to store data
all_posts <- list()
# Create the processed directory
processed_dir <- "bsky_data/processed/"
if (!dir.exists(processed_dir)) dir.create(processed_dir, recursive = TRUE)
# Load posts from each outlet
for (source in names(outlets)) {
post_files <- list.files(outlets[[source]], full.names = TRUE, pattern = "\\.rds$")
# Create a data frame for users with no posts
users <- basename(post_files) %>% gsub("\\.rds$", "", .)
source_posts <- lapply(post_files, function(file) {
data <- readRDS(file)
if (is.data.frame(data)) {
data <- data %>% mutate(source = source)  # Add source label
} else {
# Handle users with no posts
data <- data.frame(author_handle = gsub("\\.rds$", "", basename(file)), source = source)
}
return(data)
})
# Bind rows for each source
all_posts[[source]] <- bind_rows(source_posts)
}
# Combine all posts into one dataset
combined_posts <- bind_rows(all_posts)
# Ensure empty rows for users with no posts
all_users <- unique(combined_posts$author_handle)
combined_posts <- combined_posts %>%
group_by(author_handle) %>%
complete(author_handle = all_users, fill = list(source = NA)) %>%
ungroup()
